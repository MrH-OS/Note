
## http协议的特点

- 简单快速
  + 客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快
- 灵活
  + HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
- 无连接
  + 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
- 无状态
  + HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
- 支持B/S及C/S模式。

### URL一般由三部组成

- 协议(或称为服务方式)
- 存有该资源的主机IP地址(有时也包括端口号)
- 主机资源的具体地址。如目录和文件名等

### http状态代码

状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:
- 1xx：指示信息--表示请求已接收，继续处理
- 2xx：成功--表示请求已被成功接收、理解、接受
- 3xx：重定向--要完成请求必须进行更进一步的操作
- 4xx：客户端错误--请求有语法错误或请求无法实现
- 5xx：服务器端错误--服务器未能实现合法的请求

|  状态码  |  英文  |  详情  |
| :----: | :----: | :----: |
| 100 |  Continue |  继续。客户端应继续其请求 |
| 101 |  Switching Protocols |切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |
| 200 |  OK | 请求成功。一般用于GET与POST请求 |
| 201 |  Created | 已创建。成功请求并创建了新的资源 |
| 202 |  Accepted |  已接受。已经接受请求，但未处理完成 |
| 203 |  Non-Authoritative Information | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |
| 204 |  No Content |  无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 205 |  Reset Content | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| 206 |  Partial Content | 部分内容。服务器成功处理了部分GET请求 |
| 300 |  Multiple Choices |多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| 301 | Moved Permanently | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| 302 | Found | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 303 | See Other | 查看其它地址。与301类似。使用GET和POST请求查看 |
| 304 | Not Modified |  未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305 |  Use Proxy | 使用代理。所请求的资源必须通过代理访问 |
| 306 |  Unused |  已经被废弃的HTTP状态码 |
| 307 |  Temporary Redirect |  临时重定向。与302类似。使用GET请求重定向 |
| 400 |  Bad Request | 客户端请求的语法错误，服务器无法理解 |
| 401 |  Unauthorized |  请求要求用户的身份认证 |
| 402 |  Payment Required |  保留，将来使用 |
| 403 |  Forbidden | 服务器理解请求客户端的请求，但是拒绝执行此请求 |
| 404 |  Not Found |服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405 |  Method Not Allowed |  客户端请求中的方法被禁止 |
| 406 |  Not Acceptable |  服务器无法根据客户端请求的内容特性完成请求 |
| 407 |  Proxy Authentication Required | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |
| 408 |  Request Time-out |  服务器等待客户端发送的请求时间过长，超时 |
| 409 |  Conflict | 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突 |
| 410 |  Gone |  客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |
| 411 | Length Required | 服务器无法处理客户端发送的不带Content-Length的请求信息 |
| 412 | Precondition Failed | 客户端请求信息的先决条件错误 |
| 413 | Request Entity Too Large |  由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |
| 414 | Request-URI Too Large | 请求的URI过长（URI通常为网址），服务器无法处理 |
| 415 | Unsupported Media Type |  服务器无法处理请求附带的媒体格式 |
| 416 | Requested range not | satisfiable 客户端请求的范围无效 |
| 417 | Expectation Failed |  服务器无法满足Expect的请求头信息 |
| 500 | Internal Server Error | 服务器内部错误，无法完成请求 |
| 501 | Not Implemented | 服务器不支持请求的功能，无法完成请求 |
| 502 | Bad Gateway | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
| 503 | Service Unavailable  |由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504 | Gateway Time-out |  充当网关或代理的服务器，未及时从远端服务器获取请求 |
| 505 | HTTP Version not supported  | 服务器不支持请求的HTTP协议的版本，无法完成处理 |

### http请求方式

HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。
HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。

- GET     请求指定的页面信息，并返回实体主体。
- HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
- POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立或已有资源的修改。
- PUT     从客户端向服务器传送的数据取代指定的文档的内容。
- DELETE      请求服务器删除指定的页面。
- CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
- OPTIONS     允许客户端查看服务器的性能。
- TRACE     回显服务器收到的请求，主要用于测试或诊断。

### get和post区别

- get在浏览器回退是无害的, post会再次提交请求
- get产生的url地址可以被收藏, 而post不可以
- get请求会被浏览器主动缓存,post不会,除非手动设置
- get请求只能进行url编码,而post支持多种编码方式
- get请求参数会被完整的保留在浏览器历史记录中,而post中的参数不会被保留
- get请求在url中传送的参数有长度限制,post没有限制
- 对于参数数据类型,get只接受ASCII字符, post无限制
- get比post更不安全,因为参数暴露在url上,所以不能用来传递敏感信息
- get通过url传参, post参数在Request Body中

### http协议类--持久连接

http协议采用"请求-应答"模式,当使用普通模式,即非keep-alive模式时,每个请求/应答客户端和服务端都要新建一个连接,完成之后立即断开连接

当使用keep-alive模式时,keep-alive功能使客户端到服务器端的连接持续有效,当出现对服务器的后续请求时,keep-alive功能避免了建立或者重新建立连接(http1.1开始支持)

### 管线化

在使用持久连接的情况下,某个连接上消息的传递类似于
请求1 -> 响应1 -> 请求2 -> 响应2 -> 请求3 -> 响应3

管线化 --- 某个连接上的消息类似于
请求1 -> 请求2 -> 请求3 -> 响应1 -> 响应2 -> 响应3

管线化机制通过持久连接完成,进http/1.1支持此技术
只有get和head请求可以进行管线化,post有所限制
初次创建不应启动管线机制,因服务器不一定支持http/1.1版本协议



## 提升页面性能

- 资源压缩合并,减少http请求
- 非核心代码异步加载
- 利用浏览器缓存
- 使用CDN
- 预解析DNS
  + ` <meta http-equiv="x-dns-prefetch-control" content="on"> `  强制打开a标签DNS预解析(http请求中默认是开启的)
  + ` <link rel="den-prefetch" href="//host_name_to_prefetch.com"> `

- 异步加载
  + 动态脚本加载
  + defer
  + async
- 异步加载区别
  + defer在html解析完成之后才会执行,如果是多个,按照加载的顺序依次执行
  + async是在加载完之后立即执行,如果是多个,执行顺序和加载顺序无关

- 浏览器缓存
  + 强缓存
    * expires
    * Cache-Control
  + 协商缓存
    * Last-Modified If-Modified-Since
    * Etag If-None_Match

- 错误的捕获方式
  + 即时运行错误的捕获方式
    * try...catch
    * window.onerror
  + 资源加载错误
    * object.onerror
    * performance.getEntries()
    * Error事件捕获

- 跨域请求错误捕获
  + 在客户端 script标签增加crossorigin属性
  + 在服务端js资源响应头加 ` Access-Control-Allow-Origin `

- 上报错误的基本原理
  + 采用ajax通信方式上报
  + 利用image对象上报
